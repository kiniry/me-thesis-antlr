package Runners;

import java.io.IOException;

import org.antlr.runtime.ANTLRInputStream;
import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CharStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.TokenStream;
import org.antlr.runtime.tree.Tree;

import bytecodeDeobfuscation.TreeConstructorLexer;
import bytecodeDeobfuscation.TreeConstructorParser;
import bytecodeDeobfuscation.TreeConstructorParser.rule1_return;

/**
 * Helps visualizing the tree generated by the TreeConstrucor grammar.
 * 
 * Massaging consists of:
 * <ul>
 * <li> Runs the TreeConstructor lexer and parser and prints out the tree. </li>
 * </ul>
 * @author Mikkel Nielsen
 */
public class TreeConstructorRunner {

	/**
	 * Creates the lexer and parser and parses a string. Then prints out the parsed tree structure.
	 * 
	 * @param useSystemIn if true uses System.in if false a constant premade string.
	 */
	public static void PrintTree(boolean useSystemIn)
	{
		try {
			CharStream input;
			if(useSystemIn)		{
				input = new ANTLRInputStream(System.in);
			}
			else{
				input = new ANTLRStringStream("s#10.#12 ide ide 123 extends 321 some, some");
			}
			TreeConstructorLexer lexer = new TreeConstructorLexer(input);
			TokenStream tokenStream = new CommonTokenStream(lexer);
			TreeConstructorParser parser = new TreeConstructorParser(tokenStream);
			rule1_return ret = parser.rule1();
			
			System.out.println("The tree:");
			System.out.println(((Tree)ret.getTree()).toStringTree());
			
		} catch (IOException e) {
			System.out.println("Could not read anything!");
			e.printStackTrace();
		} catch (RecognitionException e) {
			e.printStackTrace();
		}
	}
}
